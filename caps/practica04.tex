\section{Encaminamiento determinista y adaptativo}\label{sec:p03intro}\pagenumbering{arabic}

\subsection{Objetivo}\label{ssec:p03objetivo}

\begin{itemize}
    \item \normalsize Poner de manifiesto el problema de llevar datos compartidos a varias caches.
    \item \normalsize Comparar protocolos de coherencia basados en invalidación y basados en actualización.
\end{itemize} 

\subsection{Desarrollo}\label{ssec:p03desarrollo}

\normalsize Se trata de poner de manifiesto el problema denominado falsa compartición (false sharing). Esta situación se da cuando unos bloques de datos son compartidos por varios procesadores. Un procesador modifica un determinado dato que pertenece a un bloque dado. Otro procesador modifica otro dato distinto pero que pertenece al mismo bloque. El bloque es llevado a las caches de ambos procesadores y, si se usa un protocolo de coherencia basado en invalidación, se producirán elevadas tasas de fallos en cache y de transferencias de bloques.

Para realizar esta práctica el alumno debe usar el simulador SMPCache (apéndice B).

\begin{itemize}
    \item [\textbf{a)}] \textbf{El alumno debe crear trazas de accesos a memoria que reproduzcan esa situación. Para ello usará el código mostrado en el Listing \ref{lst:codigo}, el cual realiza una operación elemental sobre vectores que consiste en hacer una copia de un vector en otro. Dicha copia la realizan entre varios procesadores, repartiéndose por igual las componentes del vector. Para poder ver el efecto del problema de la falsa compartición, el alumno debe considerar al menos dos formas de hacer ese reparto: una que produzca el problema de la falsa compartición y otra que no.}

    \begin{mycode}[style=cstyle, caption={Código para realizar copia de vectores y generar trazas para SMPCache.}, label=lst:codigo]
// Programa que copia un vector en otro
// Genera trazas para el simulador SMPCache
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

const int NUM = 1000; // Longitud del vector
const int N = 8;      // Maximo numero de procesadores
const int READ = 2;   // Lectura de datos
const int WRITE = 3;  // Escritura de datos
const int FETCH = 0;  // Captura de instrucciones

int n, i, proc;

// Funcion para repartir los datos entre los procesadores
int DisData(char key, int i) {
    int proc;
    switch (key) {
        // INSERTAR CODIGO
    }
    return proc;
}

// Funcion que escribe en un fichero un acceso a memoria.
// Parametros: fichero, tipo de acceso y direccion accedida
void WriteAccess(FILE *f, int type, void *address) {
    fprintf(f, "%d %p\n", type, address);
}

int main(int argc, char *argv[]) {
    char a[NUM], b[NUM]; // Vectors
    FILE *f[N]; // File per processor
    char filename[30];
    char key;
    
    if ((argc == 2) && (INSERTAR CODIGO)) {
        key = argv[1][0];
    } else {
        printf("Syntax: ...\n");
        exit(0);
    }

    for (n = 1; n <= N; n *= 2) {
        for (proc = 0; proc < n; proc++) {
            sprintf(filename, "traza%c%d_%d.prg", key, n, proc + 1);
            f[proc] = fopen(filename, "w");
        }
        for (i = 0; i < NUM; i++) {
            a[i] = b[i]; // Example operation
            proc = DisData(key, i);
            WriteAccess(f[proc], READ, &b[i]);  // Read b[i]
            WriteAccess(f[proc], WRITE, &a[i]); // Write to a[i]
        }
        for (proc = 0; proc < n; proc++) {
            fclose(f[proc]);
        }
    }
    return 0;
}
    \end{mycode}


    \textbf{Se deben hacer pruebas con 2, 4 y 8 procesadores, y por tanto se deben generar las trazas necesarias para cada uno de esos tres casos. Por ejemplo, cuando se simule un SMP con 4 procesadores son necesarios 4 ficheros de traza, uno para cada procesador. La configuración base del SMP será la dada por los siguientes parámetros:}

    \begin{itemize}
        \item \textbf{Protocolo de coherencia: MESI}
        \item \textbf{Procesadores: 8}
        \item \textbf{Arbitraje del Bus: LRU}
        \item \textbf{Tamaño de palabra: 8 bits}
        \item \textbf{Palabras por bloque: 128}
        \item \textbf{Bloques en la memoria: 8192}
        \item \textbf{Bloques en la cache: 64}
        \item \textbf{Correspondencia: Asociativa por conjuntos}
        \item \textbf{Conjuntos: 32 (2 vías)}
        \item \textbf{Reemplazo: LRU}
    \end{itemize}

    \textbf{Se debe tomar nota de los resultados que produce el simulador, y que son el número de transferencias de bloques en el bus y la tasa de fallos o aciertos de cache.}

    El código del Listing \ref{lst:codigo-solucion} es el que hay que incluir en la función \verb|DisData|. Los :

\begin{mycode}[style=cstyle, caption={Funcion para repartir los datos entre los procesadores.}, label=lst:codigo-solucion]
int DisData(char key, int i) {
    int proc;
    switch (key) {
        case 'C': 
            proc = (n * i) / NUM; /* Reparto por bloques */
            break;
        case 'I': 
            proc = i % n; /* Reparto ciclico */
            break;
    }
    return proc;
}
\end{mycode}

    También nos tenemos que asegurar de que se pasan los parámetros 'C' e 'I' al programa:

    \begin{mycode}[style=cstyle, caption={Comprobación de los parámetros del programa.}, label=lst:codigo-solucion2]
if ((argc == 2) && (argv[1][0]=='C' || argv[1][0]=='E')) {
	key = argv[1][0];
} else { 
	printf ("Sintaxis: C (Continuo) | E (entrelazado)\n");
	exit(0);
}
  \end{mycode}
	


    \item [\textbf{b)}] \textbf{Con las trazas generadas en el apartado anterior realiza una comparación de los protocolos MESI (invalidación) y Dragon (actualización). Varía el número de procesadores para realizar la comparación.}

    \item[\textbf{c)}] \textbf{Finalmente realizar una comparativa con diferente número de canales virtuales y justificar adecuadamente los resultados obtenidos.} 
    
\end{itemize}